# 데이터베이스 성능 분석 및 최적화 보고서

## 1. 서론

본 보고서는 현재 이커머스 애플리케이션의 데이터베이스 스키마를 분석하여 잠재적인 성능 병목 현상, 동시성 문제를 식별하고 최적화 솔루션을 제안합니다. 성능 테스트는 K6를 사용하여 시스템 성능 저하나 장애를 유발할 수 있는 고트래픽 작업에 초점을 맞출 것입니다.

## 2. 현재 스키마 분석

현재 스키마는 다음과 같은 주요 테이블로 구성되어 있습니다:
- `user` - 사용자 정보 저장
- `point` - 사용자 포인트/잔액 관리
- `point_history` - 포인트 거래 내역 추적
- `product` - 제품 정보 저장
- `product_stock` - 제품 재고 관리
- `coupon` - 쿠폰 상세 정보 저장
- `user_coupon` - 사용자에게 할당된 쿠폰 추적
- `order` - 주문 정보 저장
- `order_item` - 주문 내 제품 상세 정보
- `order_product_history` - 제품 주문 내역 추적
- `product_rank` - 제품 인기도 순위 저장

### 2.1 스키마 관찰 사항

스키마 분석 후 다음과 같은 관찰 사항이 도출되었습니다:

1. **인덱스 부재**: 여러 외래 키와 자주 조회되는 컬럼에 인덱스가 없어, 쿼리 성능에 상당한 영향을 미칠 수 있습니다.
2. **다대다 관계**: 사용자-쿠폰과 같은 여러 다대다 관계가 적절한 인덱싱 없이 존재합니다.
3. **비효율적인 쿼리**: 순위 계산과 같은 여러 작업이 복잡한 조인과 집계를 필요로 할 수 있습니다.
4. **파티셔닝 부재**: 대용량 테이블(주문, 포인트 내역)이 파티셔닝되어 있지 않아, 테이블이 커질수록 성능에 영향을 미칩니다.
5. **타임스탬프 쿼리**: 인덱스가 없는 타임스탬프 컬럼에 대한 날짜 기반 쿼리는 전체 테이블 스캔을 유발할 수 있습니다.

## 3. 잠재적 성능 병목 현상

### 3.1 느린 쿼리 작업

| 작업 | 설명 | 현재 문제점 | 영향 |
|-----------|-------------|----------------|--------|
| 제품 순위 계산 | 주문 내역을 기반으로 인기 제품 계산 | 적절한 인덱스가 없는 복잡한 조인 | 높은 CPU 사용률, 느린 대시보드 업데이트 |
| 사용자 쿠폰 조회 | 사용자의 사용 가능한 쿠폰 검색 | user_id + is_used 조합에 인덱스 없음 | 느린 체크아웃 프로세스 |
| 주문 내역 | 제품 상세 정보가 포함된 사용자 주문 내역 조회 | 주문 테이블 간의 여러 조인 | 느린 고객 프로필 페이지 |
| 포인트 거래 내역 | 사용자의 포인트 내역 조회 | user_id + create_date_time에 인덱스 없음 | 느린 계정 내역 페이지 |
| 쿠폰 가용성 | 발급 가능한 쿠폰 확인 | quantity + date 필드에 인덱스 없음 | 느린 프로모션 캠페인 |
| 제품 검색 | 이름이나 카테고리로 제품 검색 | 제품 이름에 전문 검색 인덱스 없음 | 느린 검색 기능 |

### 3.2 동시성 작업 문제

| 작업 | 동시성 문제 | 영향 |
|-----------|-------------------|--------|
| 쿠폰 발급 | 한정 수량 쿠폰 발급 시 경쟁 상태 | 가용 수량을 초과한 쿠폰 과잉 발급 |
| 제품 재고 업데이트 | 동시 구매 중 경쟁 상태 | 가용 재고보다 더 많은 상품 판매 |
| 포인트 거래 | 동시 포인트 작업 중 읽기-수정-쓰기 문제 | 포인트 잔액 불일치 |
| 주문 생성 | 대량 주문 처리 중 경쟁 상태 | 재고 불일치 |

## 4. K6를 이용한 성능 테스트 계획

우리의 성능 우려를 검증하기 위해 K6를 사용하여 다음과 같은 시나리오를 테스트할 것입니다:

```javascript
// 쿠폰 발급 동시성을 위한 K6 테스트 스크립트 예시
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  vus: 100,  // 100명의 가상 사용자
  duration: '30s',  // 30초 테스트
};

export default function() {
  const userId = Math.floor(Math.random() * 1000) + 1;
  const couponId = 1;  // 한정 수량 쿠폰
  
  let res = http.post('http://app-url/api/coupons/issue', JSON.stringify({
    userId: userId,
    couponId: couponId
  }), {
    headers: { 'Content-Type': 'application/json' },
  });
  
  check(res, {
    'status가 200 또는 409': (r) => r.status === 200 || r.status === 409,
  });
  
  sleep(0.1);
}
```

제품 재고 업데이트, 포인트 거래 및 기타 동시 작업에 대해서도 유사한 테스트 스크립트를 개발할 것입니다.

## 5. 데이터베이스 최적화 권장 사항

### 5.1 인덱스 최적화

| 테이블 | 제안 인덱스 | 이점 | SQL 명령 |
|-------|----------------|---------|-------------|
| user_coupon | CREATE INDEX idx_user_coupon_user_used ON user_coupon(user_id, is_used) | 더 빠른 쿠폰 조회 | `CREATE INDEX idx_user_coupon_user_used ON user_coupon(user_id, is_used);` |
| point_history | CREATE INDEX idx_point_history_user_date ON point_history(user_id, create_date_time) | 더 빠른 내역 조회 | `CREATE INDEX idx_point_history_user_date ON point_history(user_id, create_date_time);` |
| order | CREATE INDEX idx_order_user_date ON order(user_id, created_date_time) | 더 빠른 주문 내역 | `CREATE INDEX idx_order_user_date ON order(user_id, created_date_time);` |
| order_product_history | CREATE INDEX idx_oph_product_date ON order_product_history(product_id, create_date_time) | 더 빠른 순위 계산 | `CREATE INDEX idx_oph_product_date ON order_product_history(product_id, create_date_time);` |
| coupon | CREATE INDEX idx_coupon_dates ON coupon(start_date_time, end_date_time, quantity) | 더 빠른 쿠폰 가용성 확인 | `CREATE INDEX idx_coupon_dates ON coupon(start_date_time, end_date_time, quantity);` |
| product | CREATE FULLTEXT INDEX idx_product_name ON product(name) | 더 빠른 제품 검색 | `CREATE FULLTEXT INDEX idx_product_name ON product(name);` |

### 5.2 테이블 재구성

#### 5.2.1 대용량 테이블 파티셔닝

빠르게 성장하는 테이블에 파티셔닝 구현:

```sql
-- 월별 point_history 파티셔닝
ALTER TABLE point_history
PARTITION BY RANGE (YEAR(create_date_time) * 100 + MONTH(create_date_time)) (
    PARTITION p_2023_01 VALUES LESS THAN (202302),
    PARTITION p_2023_02 VALUES LESS THAN (202303),
    -- 필요에 따라 파티션 추가
    PARTITION p_future VALUES LESS THAN MAXVALUE
);

-- 월별 order 테이블 파티셔닝
ALTER TABLE `order`
PARTITION BY RANGE (YEAR(created_date_time) * 100 + MONTH(created_date_time)) (
    PARTITION p_2023_01 VALUES LESS THAN (202302),
    PARTITION p_2023_02 VALUES LESS THAN (202303),
    -- 필요에 따라 파티션 추가
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

#### 5.2.2 자주 조인되는 데이터의 비정규화

자주 접근하는 조인 데이터에 대한 비정규화 뷰 생성:

```sql
CREATE VIEW vw_user_coupons AS
SELECT uc.id, uc.user_id, uc.coupon_id, uc.is_used, uc.issued_date_time,
       c.coupon_number, c.type, c.rate, c.discount_price, c.start_date_time, c.end_date_time
FROM user_coupon uc
JOIN coupon c ON uc.coupon_id = c.id;
```

### 5.3 쿼리 최적화

쿠폰 가용성 쿼리 최적화:

```sql
-- 이전
SELECT * FROM coupon 
WHERE quantity > 0 
AND start_date_time <= NOW() 
AND end_date_time >= NOW();

-- 이후 (인덱스 사용)
SELECT * FROM coupon 
FORCE INDEX (idx_coupon_dates)
WHERE quantity > 0 
AND start_date_time <= NOW() 
AND end_date_time >= NOW();
```

제품 순위 계산 최적화:

```sql
-- 더 나은 성능을 위한 임시 테이블 사용
CREATE TEMPORARY TABLE temp_product_ranks AS
SELECT product_id, SUM(quantity) as total_quantity
FROM order_product_history
WHERE create_date_time >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
GROUP BY product_id
ORDER BY total_quantity DESC;

-- 임시 테이블에서 product_rank 테이블로 삽입
INSERT INTO product_rank (product_id, rank_date, `rank`)
SELECT product_id, CURDATE(),
       ROW_NUMBER() OVER (ORDER BY total_quantity DESC) as `rank`
FROM temp_product_ranks;
```

## 6. 동시성 문제 해결

### 6.1 쿠폰 발급 동시성 해결책

쿠폰 발급을 위한 낙관적 잠금 구현:

```java
@Transactional(isolation = Isolation.SERIALIZABLE)
public void issueCoupon(Long userId, Long couponId) {
    // 잠금을 포함한 쿠폰 조회
    Coupon coupon = couponRepository.findByIdWithLock(couponId)
        .orElseThrow(() -> new NotFoundException("쿠폰을 찾을 수 없습니다"));
    
    if (coupon.getQuantity() <= 0) {
        throw new BusinessException("사용 가능한 쿠폰이 없습니다");
    }
    
    // 쿠폰 수량 업데이트
    coupon.decreaseQuantity();
    couponRepository.save(coupon);
    
    // 사용자 쿠폰 생성
    UserCoupon userCoupon = new UserCoupon();
    userCoupon.setUserId(userId);
    userCoupon.setCouponId(couponId);
    userCoupon.setIsUsed(false);
    userCouponRepository.save(userCoupon);
}

// CouponRepository에서
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT c FROM Coupon c WHERE c.id = :id")
Optional<Coupon> findByIdWithLock(@Param("id") Long id);
```

### 6.2 제품 재고 동시성 해결책

재고 업데이트를 위한 비관적 잠금 구현:

```java
@Transactional(isolation = Isolation.SERIALIZABLE)
public void updateStock(Long productId, int quantity) {
    // 잠금을 포함한 제품 재고 조회
    ProductStock stock = productStockRepository.findByProductIdWithLock(productId)
        .orElseThrow(() -> new NotFoundException("제품 재고를 찾을 수 없습니다"));
    
    if (stock.getQuantity() < quantity) {
        throw new BusinessException("재고가 부족합니다");
    }
    
    // 재고 업데이트
    stock.decreaseQuantity(quantity);
    productStockRepository.save(stock);
}

// ProductStockRepository에서
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT ps FROM ProductStock ps WHERE ps.productId = :productId")
Optional<ProductStock> findByProductIdWithLock(@Param("productId") Long productId);
```

### 6.3 포인트 거래 동시성 해결책

적절한 격리 수준을 갖는 데이터베이스 트랜잭션 사용:

```java
@Transactional(isolation = Isolation.SERIALIZABLE)
public void usePoints(Long userId, BigDecimal amount) {
    // 잠금을 포함한 사용자 포인트 조회
    Point point = pointRepository.findByUserIdWithLock(userId)
        .orElseThrow(() -> new NotFoundException("사용자 포인트를 찾을 수 없습니다"));
    
    if (point.getPoint().compareTo(amount) < 0) {
        throw new BusinessException("포인트가 부족합니다");
    }
    
    // 포인트 업데이트
    point.use(amount);
    pointRepository.save(point);
    
    // 포인트 내역 생성
    PointHistory history = new PointHistory();
    history.setUserId(userId);
    history.setType(PointTransactionType.USE);
    history.setAmount(amount);
    pointHistoryRepository.save(history);
}

// PointRepository에서
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT p FROM Point p WHERE p.userId = :userId")
Optional<Point> findByUserIdWithLock(@Param("userId") Long userId);
```

## 7. 동시성 테스트 코드

### 7.1 쿠폰 발급 동시성 테스트

```java
@Test
@DisplayName("쿠폰 동시 발급 테스트")
void testConcurrentCouponIssue() throws InterruptedException {
    // Given
    int numberOfThreads = 100;
    ExecutorService executorService = Executors.newFixedThreadPool(10);
    CountDownLatch latch = new CountDownLatch(numberOfThreads);
    
    Long couponId = 1L; // 한정 수량(예: 50개) 쿠폰
    AtomicInteger successCount = new AtomicInteger(0);
    AtomicInteger failCount = new AtomicInteger(0);
    
    // When
    for (int i = 0; i < numberOfThreads; i++) {
        final Long userId = Long.valueOf(i + 1);
        executorService.submit(() -> {
            try {
                CouponIssueCommand command = new CouponIssueCommand(userId, couponId);
                couponFacade.issue(command);
                successCount.incrementAndGet();
            } catch (Exception e) {
                failCount.incrementAndGet();
            } finally {
                latch.countDown();
            }
        });
    }
    
    latch.await(10, TimeUnit.SECONDS);
    
    // Then
    DomainCoupon coupon = couponService.getCoupon(couponId);
    assertEquals(0, coupon.getQuantity()); // 모든 쿠폰이 발급되어야 함
    assertEquals(50, successCount.get()); // 50개만 성공해야 함
    assertEquals(50, failCount.get()); // 쿠폰이 남아있지 않아 50개는 실패해야 함
}
```

### 7.2 제품 재고 동시성 테스트

```java
@Test
@DisplayName("상품 재고 동시 업데이트 테스트")
void testConcurrentStockUpdate() throws InterruptedException {
    // Given
    int numberOfThreads = 10;
    ExecutorService executorService = Executors.newFixedThreadPool(10);
    CountDownLatch latch = new CountDownLatch(numberOfThreads);
    
    Long productId = 1L; // 재고 수량이 100인 제품
    int quantityPerOrder = 10;
    AtomicInteger successCount = new AtomicInteger(0);
    AtomicInteger failCount = new AtomicInteger(0);
    
    // When
    for (int i = 0; i < numberOfThreads; i++) {
        executorService.submit(() -> {
            try {
                productStockService.delivering(productId, quantityPerOrder);
                successCount.incrementAndGet();
            } catch (Exception e) {
                failCount.incrementAndGet();
            } finally {
                latch.countDown();
            }
        });
    }
    
    latch.await(10, TimeUnit.SECONDS);
    
    // Then
    DomainProductStock stock = productStockRepository.findByProductId(productId);
    assertEquals(0, stock.getQuantity()); // 재고가 소진되어야 함
    assertEquals(10, successCount.get()); // 10개 모두 성공해야 함
    assertEquals(0, failCount.get()); // 실패는 없어야 함
}
```

### 7.3 포인트 거래 동시성 테스트

```java
@Test
@DisplayName("포인트 동시 사용 테스트")
void testConcurrentPointUsage() throws InterruptedException {
    // Given
    int numberOfThreads = 5;
    ExecutorService executorService = Executors.newFixedThreadPool(5);
    CountDownLatch latch = new CountDownLatch(numberOfThreads);
    
    Long userId = 1L; // 1000 포인트를 가진 사용자
    BigDecimal amountPerTransaction = new BigDecimal(200); // 각 트랜잭션은 200 포인트 사용
    AtomicInteger successCount = new AtomicInteger(0);
    AtomicInteger failCount = new AtomicInteger(0);
    
    // When
    for (int i = 0; i < numberOfThreads; i++) {
        executorService.submit(() -> {
            try {
                pointService.use(userId, amountPerTransaction);
                successCount.incrementAndGet();
            } catch (Exception e) {
                failCount.incrementAndGet();
            } finally {
                latch.countDown();
            }
        });
    }
    
    latch.await(10, TimeUnit.SECONDS);
    
    // Then
    DomainPoint point = pointService.getPoint(userId);
    assertEquals(new BigDecimal(0), point.getPoint()); // 모든 포인트가 사용되어야 함
    assertEquals(5, successCount.get()); // 모든 5개 트랜잭션이 성공해야 함
    assertEquals(0, failCount.get()); // 실패는 없어야 함
}
```

## 8. 구현 계획

### 8.1 단기 실행 사항 (1-2주)

1. 제안된 모든 인덱스 구현
2. 중요 작업에 동시성 제어 추가
3. 가장 문제가 되는 쿼리 최적화
4. 초기 K6 성능 테스트 실행

### 8.2 중기 실행 사항 (1-2개월)

1. 대용량 테이블에 테이블 파티셔닝 구현
2. 자주 조인되는 데이터에 대한 비정규화 뷰 생성
3. 최적화된 쿼리를 활용하도록 애플리케이션 코드 리팩토링
4. 자주 접근하는 데이터에 대한 캐싱 구현

### 8.3 장기 개선 사항 (3개월 이상)

1. 읽기/쓰기 분리 아키텍처로 전환 고려
2. 특정 대용량 사용 사례에 대한 NoSQL 솔루션 평가
3. 과거 데이터에 대한 데이터 아카이빙 전략 구현
4. 지속적인 성능 모니터링 설정

## 9. 결론

현재 데이터베이스 스키마에는 특히 쿠폰 발급, 제품 재고 관리, 포인트 거래 주변의 잠재적인 성능 병목 현상이 여러 개 있습니다. 제안된 인덱스 최적화, 쿼리 개선, 동시성 제어를 구현함으로써 이커머스 애플리케이션의 성능과 신뢰성을 크게 향상시킬 수 있습니다.

K6를 이용한 정기적인 성능 테스트는 이러한 개선 사항을 검증하고 남아 있는 문제를 식별하는 데 도움이 될 것입니다. 애플리케이션이 성장함에 따라 데이터베이스 성능을 계속 모니터링하고 필요에 따라 추가 최적화를 진행해야 합니다.