# 분산락(Distributed Lock) 적용 보고서

## 목차
1. [분산락 개요](#분산락-개요)
2. [락 메커니즘 기본 개념](#락-메커니즘-기본-개념)
   - [Simple Lock](#simple-lock)
   - [Spin Lock](#spin-lock)
   - [Pub-Sub 기반 락](#pub-sub-기반-락)
3. [프로젝트 적용 사례](#프로젝트-적용-사례)
   - [CouponFacade - 쿠폰 선착순 발급](#couponfacade---쿠폰-선착순-발급)
   - [OrderFacade - 상품 주문 처리](#orderfacade---상품-주문-처리)
4. [결론 및 향후 개선 방향](#결론-및-향후-개선-방향)

## 분산락 개요

분산락(Distributed Lock)은 여러 서버나 프로세스가 공유 리소스에 동시에 접근하는 것을 제어하는 메커니즘입니다. 단일 서버 환경에서는 로컬 락(Local Lock)으로 충분하지만, 여러 서버가 동일한 리소스에 접근하는 분산 환경에서는 분산락이 필요합니다.

분산락의 주요 목적:
- **동시성 제어**: 여러 서버에서 동시에 접근하는 공유 리소스의 일관성 유지
- **경쟁 상태(Race Condition) 방지**: 동시 요청으로 인한 데이터 불일치 방지
- **선착순 처리**: 한정된 리소스에 대한 공정한 분배

## 락 메커니즘 기본 개념

### Simple Lock

Simple Lock은 가장 기본적인 락 구현 방식으로, 리소스 접근 전에 락을 획득하고 작업 완료 후 락을 해제하는 방식입니다.

**특징:**
- 구현이 간단하고 직관적
- 락 획득 실패 시 즉시 에러 반환 또는 대기열에 추가
- 데드락(Deadlock) 발생 가능성 있음

**구현 예시:**
```java
public void acquireLock(String lockKey) {
    boolean acquired = redisTemplate.opsForValue().setIfAbsent(lockKey, "LOCKED", Duration.ofSeconds(30));
    if (!acquired) {
        throw new RuntimeException("Lock acquisition failed");
    }
}

public void releaseLock(String lockKey) {
    redisTemplate.delete(lockKey);
}
```

### Spin Lock

Spin Lock은 락을 획득할 때까지 반복적으로 시도하는 방식입니다. CPU 자원을 소모하지만, 대기 시간이 짧을 것으로 예상되는 경우 효율적일 수 있습니다.

**특징:**
- 락 획득 실패 시 일정 시간 대기 후 재시도
- 긴 대기 시간 동안 CPU 리소스 소모
- 짧은 락 보유 시간에 효과적

**구현 예시:**
```java
public void acquireSpinLock(String lockKey, long timeoutMs) {
    long startTime = System.currentTimeMillis();
    boolean acquired = false;
    
    while (!acquired && System.currentTimeMillis() - startTime < timeoutMs) {
        acquired = redisTemplate.opsForValue().setIfAbsent(lockKey, "LOCKED", Duration.ofSeconds(30));
        if (!acquired) {
            try {
                Thread.sleep(100); // 재시도 전 짧은 대기
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    if (!acquired) {
        throw new RuntimeException("Lock acquisition failed after timeout");
    }
}
```

### Pub-Sub 기반 락

Pub-Sub(발행-구독) 패턴을 활용한 락 메커니즘은 락 해제 이벤트를 구독하여 효율적으로 락 획득을 시도하는 방식입니다.

**특징:**
- 락 해제 시 이벤트 발행으로 대기 중인 프로세스에 알림
- 불필요한 락 획득 시도 감소로 효율성 증가
- 메시지 브로커(Redis, Kafka 등) 의존성 있음

**구현 예시:**
```java
public void acquirePubSubLock(String lockKey) {
    // 락 획득 시도
    boolean acquired = redisTemplate.opsForValue().setIfAbsent(lockKey, "LOCKED", Duration.ofSeconds(30));
    
    if (!acquired) {
        // 락 해제 이벤트 구독
        String channel = "lock:" + lockKey + ":release";
        redisTemplate.listenToChannel(channel, message -> {
            // 락 해제 이벤트 수신 시 락 획득 재시도
            acquirePubSubLock(lockKey);
        });
    }
}

public void releasePubSubLock(String lockKey) {
    redisTemplate.delete(lockKey);
    // 락 해제 이벤트 발행
    String channel = "lock:" + lockKey + ":release";
    redisTemplate.convertAndSend(channel, "RELEASED");
}
```

## 프로젝트 적용 사례

### CouponFacade - 쿠폰 선착순 발급

선착순 쿠폰 발급은 분산락의 전형적인 적용 사례입니다. 한정된 수량의 쿠폰을 여러 사용자가 동시에 요청할 때 발생하는 경쟁 상태를 방지해야 합니다.

**문제 상황:**
- 100개 한정 쿠폰에 1000명의 사용자가 동시 요청
- 분산 서버 환경에서 각 서버가 독립적으로 쿠폰 발급 처리
- 동시 요청으로 인한 초과 발급 가능성

**분산락 적용 방식:**
```java
@Service
public class CouponFacadeImpl implements CouponFacade {
    
    private final RedisLockService lockService;
    private final CouponService couponService;
    
    public CouponFacadeImpl(RedisLockService lockService, CouponService couponService) {
        this.lockService = lockService;
        this.couponService = couponService;
    }
    
    @Override
    public CouponIssueResult issueCoupon(Long userId, String couponCode) {
        String lockKey = "coupon:issue:" + couponCode;
        
        try {
            // 분산락 획득
            boolean lockAcquired = lockService.acquireLock(lockKey, 10000);
            
            if (!lockAcquired) {
                return CouponIssueResult.LOCK_ACQUISITION_FAILED;
            }
            
            // 쿠폰 수량 확인 및 발급 처리
            if (couponService.isAvailable(couponCode)) {
                return couponService.issueCoupon(userId, couponCode);
            } else {
                return CouponIssueResult.COUPON_EXHAUSTED;
            }
            
        } finally {
            // 락 해제
            lockService.releaseLock(lockKey);
        }
    }
}
```

**적용 효과:**
- 쿠폰 초과 발급 방지
- 정확한 선착순 처리 보장
- 시스템 부하 분산

### OrderFacade - 상품 주문 처리

상품 주문 처리에서는 동시 주문으로 인한 재고 불일치 문제를 해결하기 위해 분산락을 적용합니다.

**문제 상황:**
- 여러 사용자가 동시에 같은 상품 주문
- 재고 차감 로직의 원자성 보장 필요
- 분산 서버 환경에서의 일관성 유지 어려움

**분산락 적용 방식:**
```java
@Service
public class OrderFacadeImpl implements OrderFacade {
    
    private final RedisLockService lockService;
    private final InventoryService inventoryService;
    private final OrderService orderService;
    
    public OrderFacadeImpl(RedisLockService lockService, 
                           InventoryService inventoryService,
                           OrderService orderService) {
        this.lockService = lockService;
        this.inventoryService = inventoryService;
        this.orderService = orderService;
    }
    
    @Override
    public OrderResult createOrder(OrderRequest request) {
        // 주문 상품별 락 키 생성
        List<String> lockKeys = request.getItems().stream()
                .map(item -> "inventory:item:" + item.getItemId())
                .collect(Collectors.toList());
        
        // 여러 상품에 대한 락 획득 (데드락 방지를 위해 정렬)
        Collections.sort(lockKeys);
        
        try {
            // 모든 상품에 대한 락 획득
            for (String lockKey : lockKeys) {
                boolean acquired = lockService.acquireSpinLock(lockKey, 5000);
                if (!acquired) {
                    // 획득 실패 시 이미 획득한 락 해제 후 실패 반환
                    for (String acquiredKey : lockKeys.subList(0, lockKeys.indexOf(lockKey))) {
                        lockService.releaseLock(acquiredKey);
                    }
                    return OrderResult.LOCK_ACQUISITION_FAILED;
                }
            }
            
            // 재고 확인
            for (OrderItemRequest item : request.getItems()) {
                if (!inventoryService.checkStock(item.getItemId(), item.getQuantity())) {
                    return OrderResult.OUT_OF_STOCK;
                }
            }
            
            // 재고 차감 및 주문 생성
            for (OrderItemRequest item : request.getItems()) {
                inventoryService.decreaseStock(item.getItemId(), item.getQuantity());
            }
            
            return orderService.createOrder(request);
            
        } finally {
            // 모든 락 해제
            for (String lockKey : lockKeys) {
                lockService.releaseLock(lockKey);
            }
        }
    }
}
```

**적용 효과:**
- 재고 초과 판매 방지
- 정확한 재고 관리
- 주문 처리의 원자성 보장

## 결론 및 향후 개선 방향

본 프로젝트에서는 분산락을 통해 동시성 이슈를 효과적으로 해결하였습니다. 쿠폰 발급과 상품 주문 처리에서 분산락을 적용하여 데이터 일관성을 유지하고 사용자 경험을 개선했습니다.

**향후 개선 방향:**

1. **락 획득 실패 시 재시도 정책 개선**
   - 지수 백오프(Exponential Backoff) 적용
   - 최대 재시도 횟수 및 시간 조정

2. **락 획득 대기열 구현**
   - 공정한 락 획득 기회 제공
   - 시스템 부하 제어

3. **모니터링 시스템 구축**
   - 락 획득/해제 상태 실시간 모니터링
   - 데드락 감지 및 자동 해결 메커니즘

4. **장애 대응 체계 강화**
   - 락 서버(Redis 등) 장애 시 대체 전략
   - 자동 복구 메커니즘 구현

분산락은 분산 시스템의 동시성 제어에 필수적인 요소이며, 적절한 구현과 운영을 통해 시스템의 안정성과 일관성을 크게 향상시킬 수 있습니다.